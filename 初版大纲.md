

### 大纲1.0：“准备 -> 配置 -> 执行 -> 评估”


#### 阶段一：准备阶段 - 信息输入 (Data Input)

此阶段的目标是从用户那里收集所有原始材料，并通过一个**起始 API** 将其安全地发送到后端，后端将利用这些材料“塑造”AI 面试官。

**1.1. 前端 (UI Layer)**

- **组件:** `InterviewSetupForm.jsx`
    
- **功能:** 提供一个表单，包含以下字段：
    
    1. `target_position` (必需)
        
    2. `resume_file` (必需) - **[变更]** 从 `resume_content` (文本) 变更为文件上传 (支持.pdf, .md, .png, .jpg)。
        
    3. `job_description` (可选)
        
    4. `company_name` (可选) - **[新功能]**
        
    5. `additional_info` (可选)
        
- **动作:** 用户点击“开始模拟面试”按钮。
    
- **API 调用:**
    
    JavaScript
    
    ```
    // frontend/services/api.js
    async function startInterview(formData) {
      // formData 现在是一个 FormData 对象，或一个包含文件信息的 JSON
      // 例如: { resume: { mimeType: 'image/png', data: 'base64...' }, ... }
      return await apiClient.post('/api/v1/interview/start', formData);
    }
    ```
    
**1.3. 多模态处理说明**

- **文件处理策略:**
    - **PDF/.md 文件:** 直接提取文本内容
    - **图片文件 (.png, .jpg):** 通过后端 OCR 服务提取文本，或使用多模态 LLM (如 Gemini Pro Vision, GPT-4o) 直接处理
    - **前端预处理:** 在上传前显示文件类型和大小验证，提供 OCR 处理进度提示
    
- **异常处理:**
    - **文件格式错误:** 提示用户支持的文件格式和大小限制
    - **OCR 失败:** 提供手动输入简历文本的备选方案
    - **文件损坏:** 显示清晰的错误信息并允许重新上传
    

**1.2. 后端 (Brain Layer)**

- **API 端点:** `POST /api/v1/interview/start`
    
- **核心动作:**
    
    1. **[新] 公司背景研究 (Company Research):**
        
        - **触发:** 如果 `company_name` 字段**非空**。
            
        - **动作:** 后端服务调用 `Google Search` 工具。
            
        - **Tool Call:** `Google Search(queries=["[Company Name] main business", "[Company Name] industry and products", "关于 [Company Name] 的介绍"])`
            
        **(!!)[LLM Call #1] 优化版: `P-CORP-SUMMARIZE` (公司情境结构化)**

> **[System Prompt]:**
> 
> 你是一个高效的**面试情境协调员 (Interview Context Coordinator)**。你的任务是快速分析关于 “[Company Name]” 的搜索结果，并提取用于设置下游AI面试官角色的关键信息。你的输出必须是结构化的。

> **[User Prompt]:**
> 
> **搜索结果:**
> 
> ```
> [Search Snippet 1]
> [Search Snippet 2]
> ...
> [Search Snippet N]
> ```
> 
> **你的任务:** 请严格按照以下 JSON 格式，提取并总结该公司的情境信息：
> 
> JSON
> 
> ```
> {
>   "company_name": "[Company Name]",
>   "company_summary": "<这里生成一段 2-3 句话的总结，清晰描述其核心业务、市场定位和主要产品线>",
>   "key_focus_areas": [
>     "<从搜索结果中提取的业务关键词1 (例如: 智能家居)>",
>     "<业务关键词2 (例如: 机器人与自动化)>",
>     "<业务关键词3 (例如: B端楼宇科技)>",
>     "<其他相关核心技术或领域...>"
>   ]
> }
> ```
            
    2. **创建会话 (Session):**
        
        - **[变更]** 接收简历文件数据，如果是文本直接使用，如果是图片则准备好多模态输入。
        - 生成一个唯一的 `session_id`。
        - 将所有输入（简历、JD、`company_summary`[来自 LLM #1 的输出]）存储在服务器端的会话存储中（MVP 阶段可以是内存字典，未来是 Redis 或数据库）。
            
    3. **触发阶段二:** 调用内部的“角色理解”逻辑。
        
    4. **返回:** 向前端返回 `session_id` 和阶段二（角色确认）所需的数据。
        

---

#### 阶段二：配置阶段 - 确认与设置 (Configuration)

此阶段的目标是确保 AI 面试官的“人设”准确无误，并让用户完成最终设置。

**2.1. 角色理解与确认 (LLM Verification)**

- **后端 (Brain Layer) - 内部触发:**
    
    - **触发:** 在 `POST /api/v1/interview/start` 逻辑的末尾，如果**未提供** `job_description` (JD)。
        
    - **(!!)[LLM Call #2] 优化版: `P-CONTEXT-CLARIFY` (情境推导与歧义消除)**

> **[System Prompt]:**
> 
> 你是一位资深的**技术招聘负责人 (Tech Recruiting Lead)**，拥有敏锐的洞察力。你的任务不是扮演面试官，而是**分析和验证**即将进行的面试情境。你必须找出输入信息中的歧义（Ambiguity）或缺失（Gap），并提出一个推论性的确认问题。

> **[User Prompt]:**
> 
> **分析以下面试输入数据：**
> 
> 1. **目标岗位:** `[target_position]`
>     
> 2. **候选人简历:** `[resume_content]`
>     
> 3. **目标公司情境 (JSON):** `[company_context_json]` _(来自 P1 的 JSON 输出)_
>     
> 
> **你的任务:**
> 
> 4. **分析歧义：**
>     
>     - 检查 `[target_position]` 是否存在多种行业解释（例如：“量化”）。
>         
>     - 检查 `[company_context_json]` 是否信息不足 (例如 `company_summary` 为空或过于泛化)。
>         
> 5. **进行推导：**
>     
>     - 结合 `[resume_content]`（例如：简历显示 Python, ML 技能）和 `[target_position]`（例如：“量化”）。
>         
>     - _或者_ 结合 `[resume_content]`（例如：React 技能）和 `[company_context_json]`（例如：`key_focus_areas` 包含 "智能家居"）。
>         
> 6. **生成确认：**
>     
>     - 生成一段 2-3 句话的“情境确认”描述。
>         
>     - 这段描述必须**明确提出你的推论**。
>         
>     - 最后必须以一个确认问题结尾。
>         
> 
> ---
> 
> **[Assistant Output (Example 1: 岗位歧义)]:** "我注意到您的目标岗位是 [量化研究员]，而您的简历重点在 [PyTorch 和深度学习]。为了确保面试的精准性，我推测您申请的是 [AI 模型的模型量化（Model Quantization）] 领域，而不是 [金融交易策略的量化（Financial Quant）] 领域。这是您期望的面试情境吗？"
> 
> **[Assistant Output (Example 2: 公司情境推导)]:** "根据您的 [前端开发] 岗位和简历（显示您精通 React），结合 [美的集团] 的业务情境（专注于 [智能家居]），我推测这个角色不仅需要前端技能，还会重点考察 [IoT 设备或智能家居应用的联动] 方面。这是您期望的面试情境吗？"
> 
> **[Assistant Output (Example 3: 公司信息缺失)]:** "我未能查询到 [XYZ 创新工坊] (目标公司) 的具体业务信息。但根据您的 [后端工程师] 岗位和简历中的 [高并发/Socket] 经验，我将假设这是一个 [实时通信 (RTC) 或游戏后端] 的面试情境。这是您期望的面试情境吗？"
        
- **前端 (UI Layer):**
    
    - **组件:** `RoleVerificationModal.jsx`
        
    - **功能:**
        
        - 显示从后端收到的“角色确认”文本 (来自 LLM #2)。
            
        - 提供按钮：“[确认，开始面试]” 或 “[修正]”（并附带一个输入框）。
            
    - **API 调用 (如果修正):**
        
        JavaScript
        
        ```
        // frontend/services/api.js
        async function correctRole(sessionId, correctionText) {
          return await apiClient.post('/api/v1/interview/configure', {
            session_id: sessionId,
            role_correction: correctionText
          });
        }
        ```
        

**2.2. 面试参数设置 (Settings)**

- **前端 (UI Layer):**
    
    - **组件:** `SettingsForm.jsx`
        
    - **功能:**
        - **[新功能]** 允许用户选择 AI 服务提供商，选项包括：
            - `Google` (默认)
            - `OpenAI`
            - `Ollama` (本地)
        - **[新功能]** 允许用户根据选择的服务商，指定具体的 AI 模型。默认模型为 Google 的 `gemini-2.5-flash`，以确保响应速度。
        - 其他设置：面试模式（A/B）、问题数量、难度等级。
        
    - **API 调用 (最终确认):**
        
        JavaScript
        
        ```
        // frontend/services/api.js
        async function confirmSettings(sessionId, settings) {
          // settings 对象现在必须包含 AI 服务商和模型信息
          // 例如: { provider: 'google', model: 'gemini-2.5-flash', mode: 'A', count: 10, difficulty: 'Senior' }
          return await apiClient.post('/api/v1/interview/start_session', { session_id: sessionId, ...settings });
        }
        ```
        
- **后端 (Brain Layer):**
    
    - **API 端点:** `POST /api/v1/interview/start_session`
        
    - **核心动作:**
        
        1. 将会话状态标记为“进行中”。
            
        2. **[变更]** 保存完整的 `settings` (包括 `provider`, `model`, `difficulty` 等) 到该 `session_id` 对应的会话记录中。
            
        3. **触发“阶段三”：** 调用内部逻辑，生成**第一个**面试问题。
            

---

#### 阶段三：执行阶段 - 模拟面试 (Simulation)

这是核心的问答循环，完全由后端 API 驱动。

- **后端 (Brain Layer) - 内部触发:**
    
    - (!!)[LLM Call #3] 优化版: P-QUESTION-GENERATE (动态问题生成与决策)

[System Prompt]:

你是一位 [Difficulty] 级别的资深面试官，正在 [Company Summary] (如果存在) 进行一场 [Target Position] 的面试。你的提问必须严格、专业、富有洞察力。

你的核心任务是根据对话历史动态调整策略，在必要时进行深入追问 (Probe)，在适当时开启新话题 (Pivot)。

[User Prompt]:

面试档案:

面试情境: 这是 [Total Questions] 个问题中的第 [Current N] 个。

候选人资料:

简历: [resume_content]

JD: [job_description]

已确认的面试情境: [confirmed_context] (来自 P2 的最终确认结果)

面试历史 (Q&A):

[Chat History... (Q1, A1, Q2, A2... Q(N-1), A(N-1))]

你的任务：(!! 严格遵循以下决策树 !!)

1. 分析上一轮回答 (Analysis):

审查 [Chat History] 中的最后一条答案 [A(N-1)] (如果存在)。

评估该答案是否：(a) 过于宽泛 (b) 回避了核心问题 (c) 缺乏技术深度或清晰的 STAR 结构？

2. 决策与行动 (Decision & Action):

(A) 决策：追问 (Follow-up)

如果 [A(N-1)] 存在且符合 (a), (b), (c) 中任意一项：

行动： 生成一个针对 [A(N-1)] 的、更深入的追问 (Follow-up Question)。你的目标是“挖掘”候选人未明确表述的细节。

(B) 决策：提新问题 (New Question)

如果 这是第一个问题 (N=1)，或者 [A(N-1)] 回答质量达标：

行动： 生成一个全新的面试问题。

新问题约束 (Constraints):

[负向约束] 此问题的主题绝不能与 [Chat History] 中所有 Q1 到 Q(N-1) 的问题重复。

[情境约束] 此问题必须严格结合 [confirmed_context]、[resume_content] 和 [job_description] 进行设计，体现 [Difficulty] 级别的专业性。

[格式] 只输出问题本身，不要有任何多余的寒暄 (例如 "好的，那么...")。
        
- **前端 (UI Layer):**
    
    - **组件:** `ChatInterface.jsx`
        
    - **功能:**
        
        - 在聊天气泡中显示 AI 的问题 (来自 LLM #3)。
            
        - 提供一个输入框让用户输入答案。
            
        - 点击“提交回答”按钮。
            
    - **API 调用:**
        
        JavaScript
        
        ```
        // frontend/services/api.js
        async function submitAnswer(sessionId, answerText) {
          // 在发送时，前端应显示“AI 思考中...”的加载状态
          return await apiClient.post('/api/v1/interview/submit_answer', {
            session_id: sessionId,
            answer: answerText
          });
        }
        ```
        
- **后端 (Brain Layer):**
    
    - **API 端点:** `POST /api/v1/interview/submit_answer`
        
    - **核心动作:**
        
        1. 接收并保存用户的 `answer` 到会话历史。
            
        2. 检查是否达到 `Total Questions` 限制。
            
        3. **如果未结束:**
            
            - 再次调用 **[LLM Call #3: `P-QUESTION-GENERATE`]** 来获取_下一个_问题（LLM 会看到包含最新答案的“面试历史”，从而实现“追问”）。
                
            - 将新问题返回给前端。
                
        4. **如果已结束:**
            
            - 触发“阶段四”：调用内部的“评估逻辑”。
                
            - 向前端返回一个“评估中”的状态。
                

_(注：对于“模式 B: 全自动演示”，后端在收到 `submit_answer` 请求时，会先调用一个 [LLM Call #3.5: `P-DEMO-ANSWER`] 来生成“示例回答”，然后再调用 LLM #3 生成下一个问题。)_

---

#### 阶段四：评估阶段 - 反馈与总结 (Feedback)

这是“大脑”进行最终复盘的阶段。

- **后端 (Brain Layer) - 内部触发:**
    
    - **触发:** 当最后一个问题回答完毕时。
        
    - **核心动作:** 从会话中提取所有数据（简历、JD、公司情境、完整的 Q&A 历史）。
        
    - **上下文窗口管理:** 
        - **长对话处理:** 如果面试问题超过15个，系统会自动生成中间摘要，只向 LLM 提供关键信息和最近的5个问题对话历史
        - **分段处理:** 对于超长简历或JD，系统会进行智能分段，确保重要信息不被截断
        
    - **(!!)[LLM Call #4] 优化版: `P-FINAL-REPORT` (综合评估报告)**

> **[System Prompt]:**
> 
> 你是一位顶级的职业规划导师和面试专家。你将对一场刚刚结束的模拟面试进行全面、深入、且富有建设性的评估。你的评估必须**客观公正**、**数据驱动**（基于提供的档案），并以**严格的 JSON 格式**输出。

> **[User Prompt]:**
> 
> **面试档案 (Inputs):**
> 
> - 岗位: `[Target Position]`
>     
> - 公司情境: `[Company Summary]`
>     
> - 难度: `[Difficulty]`
>     
> - 简历: `[resume_content]`
>     
> - 岗位描述 (JD): `[job_description]` *(!! 关键补充 !!) *
>     
> 
> **面试完整记录 (Q&A):**
> 
> ```
> Q1: [Question 1]
> A1: [Answer 1]
> ```

> Q2: [Question 2] A2: [Answer 2] ...
> 
> ```
> 
> **你的任务 (\!\! 严格遵循以下步骤 \!\!)**
> ```

> **1. 综合分析 (Analysis):** 仔细审查上述所有输入，包括简历、JD、公司情境以及完整的 Q&A 记录。

> **2. 评分指南 (Rubric):** 你必须严格按照以下指南来生成 `scoring_matrix` 中的分数：

> - `skill_match`: 必须基于 Q&A 中展示的技术能力与 `[job_description]` 和 `[resume_content]` 的匹配程度。
>     
> - `company_fit`: 必须评估候选人的回答与 `[Company Summary]` 情境的关联性（例如，是否理解公司的业务领域如 IoT/AI/电商）。
>     
> - `communication_clarity`: 评估候选人表达的逻辑性、清晰度和专业性。
>     
> - `star_method_application`: **仅**评估行为面试问题（例如“描述一个你...的经历”）的回答是否遵循了 STAR 结构（Situation, Task, Action, Result）。
>     

> **3. 生成报告 (Generation):** 严格按照以下**有效**的 JSON 格式，生成详细的面试反馈报告。

> JSON
> 
> ```
> {
>   "overall_score": <一个 0-100 的总分 (必须是评分矩阵各项的加权反映)>,
>   "overall_summary": "<一段 2-3 句话的总体评价，必须论证 'overall_score' 的合理性>",
>   "scoring_matrix": {
>     "skill_match": <0-10 分，严格遵循 Rubric 2.a>,
>     "company_fit": <0-10 分，严格遵循 Rubric 2.b>,
>     "communication_clarity": <0-10 分，严格遵循 Rubric 2.c>,
>     "star_method_application": <0-10 分，严格遵循 Rubric 2.d>
>   },
>   "per_question_analysis": [
>     {
>       "question": "[Question 1]",
>       "answer": "[Answer 1]",
>       "feedback_strengths": "<关于这个回答的优点和亮点>",
>       "feedback_improvements": "<关于这个回答的具体改进建议（例如：'缺乏量化结果'或'未能展示深度思考'）>",
>       "suggested_answer": "<一个针对此问题的更优回答示例，展示理想的结构和内容>"
>     },
>     {
>       "question": "[Question 2]",
>       "answer": "[Answer 2]",
>       "feedback_strengths": "<...>",
>       "feedback_improvements": "<...>",
>       "suggested_answer": "<...>"
>     }
>     // ... 为每一个 Q&A 对重复此对象结构 ...
>   ],
>   "final_recommendations": [
>     "<对候选人最关键的 1-2 个改进建议 (例如: '在回答中增加 STAR 结构')>",
>     "<对候选人技术或沟通方面的其他关键建议>"
>   ]
> }
> ```
        
- **后端 (Brain Layer):**
    
    - **API 端点:** `GET /api/v1/interview/report?session_id=...` (前端在收到“评估中”状态后轮询或用 WebSocket 接收此报告)。
        
    - **核心动作:** 返回 [LLM Call #4] 生成的 JSON 报告。
        
- **前端 (UI Layer):**
    
    - **组件:** `FinalReport.jsx`
        
    - **功能:**
        
        - 获取并解析报告 JSON。
            
        - 以信息图表（用于 `scoring_matrix`）、手风琴折叠（用于 `per_question_analysis`）等富 UI 形式，优雅地展示这份完整的评估报告。
